// Generated by CoffeeScript 1.4.0
(function() {
  var SVN, SVN_ROOT, SVN_ROOT_NAME, checkout_svn_root, convertMD5path, create_temp_images_dir, err, grep_images_path, svn, syspath, temp, update_svn, upload_to_dev, upload_to_prd, utils, _;

  utils = require("../util");

  syspath = require("path");

  temp = require("temp");

  _ = require("underscore");

  SVN = require("node.svn");

  exports.usage = "处理项目图片 fekit image [upload]";

  exports.set_options = function(optimist) {
    optimist.alias('d', 'development');
    optimist.describe('d', 'upload 时使用，上传图片至开发机，默认上传选项');
    optimist.alias('p', 'production');
    return optimist.describe('p', 'upload 时使用，上传图片至外网');
  };

  exports.run = function(options) {
    return utils.proc.checkEnvironment(['rsync', 'svn'], function() {
      var command;
      if (!utils.path.exists(utils.path.join(options.cwd, 'fekit.config'))) {
        err("请在 fekit 项目中运行该功能");
      }
      if (!utils.path.exists(utils.path.join(options.cwd, 'images'))) {
        err("项目中必须存在 images 目录才能使用该功能");
      }
      command = options['_'][1];
      switch (command) {
        case 'upload':
          if (options.development || (!options.development && !options.production)) {
            upload_to_dev(options);
          }
          if (options.production) {
            return upload_to_prd(options);
          }
          break;
        case 'check':
          break;
        default:
          return utils.logger.log("请使用 fekit image --help 查看帮助");
      }
    });
  };

  SVN_ROOT = 'http://svn.corp.qunar.com/svn/sources.qunar.com/trunk';

  SVN_ROOT_NAME = "sources.qunar.com";

  svn = null;

  checkout_svn_root = function(cb) {
    utils.logger.log("正在创建缓存目录，请稍等...");
    return svn.checkout("--depth empty " + SVN_ROOT + " .", function(error, output) {
      if (error) {
        return err(error);
      } else {
        return cb();
      }
    });
  };

  update_svn = function(path, cb) {
    var i, n, _i, _path;
    _path = [];
    n = path.length;
    for (i = _i = n; n <= 1 ? _i <= 1 : _i >= 1; i = n <= 1 ? ++_i : --_i) {
      _path.unshift(path.slice(0, i).join('/'));
    }
    return utils.async.series(_path, function(uri, done) {
      return svn.up(["--set-depth", "empty", uri], done);
    }, function(error) {
      utils.file.mkdirp(utils.path.join(svn.root, path.join(utils.path.SEPARATOR)));
      return cb && cb();
    });
  };

  grep_images_path = function(root, cb) {
    var find, i, key, o, r, val, _i, _key, _len, _o, _val;
    r = [];
    utils.path.each_directory(root, function(fullpath, path) {
      var d;
      d = utils.path.dirname(path);
      if (d !== ".") {
        return r.push(d);
      }
    }, true, root);
    o = {};
    for (_i = 0, _len = r.length; _i < _len; _i++) {
      i = r[_i];
      o[i] = i.split(utils.path.SEPARATOR);
    }
    _o = {};
    for (key in o) {
      val = o[key];
      find = false;
      for (_key in o) {
        _val = o[_key];
        if (_key !== key && _key.indexOf(key) === 0) {
          find = true;
        }
      }
      if (!find) {
        _o[key] = val;
      }
    }
    return (function() {
      var _results;
      _results = [];
      for (key in _o) {
        val = _o[key];
        _results.push(val);
      }
      return _results;
    })();
  };

  upload_to_prd = function(options) {
    var basedir, dir, images_path, paths, prjname;
    basedir = utils.path.tmpdir;
    dir = utils.path.join(basedir, SVN_ROOT_NAME);
    svn = new SVN(dir);
    prjname = utils.path.basename(options.cwd);
    images_path = utils.path.join(options.cwd, 'images' + utils.path.SEPARATOR);
    paths = grep_images_path(images_path);
    paths = _.map(paths, function(i) {
      return [prjname].concat(i);
    });
    return checkout_svn_root(function() {
      return utils.async.series(paths, function(path, done) {
        return update_svn(path, function() {
          return done();
        });
      }, function(error) {
        return create_temp_images_dir(options, function(dirpath) {
          return utils.path.each_directory(dirpath, function(fullpath, partpath) {
            return utils.file.copy(fullpath, utils.path.join(dir, prjname, partpath));
          }, true, dirpath);
        });
      });
    });
  };

  upload_to_dev = function(options) {
    var images_path, prjname;
    prjname = utils.path.basename(options.cwd);
    images_path = utils.path.join(options.cwd, 'images' + utils.path.SEPARATOR);
    return create_temp_images_dir(options, function(dirpath) {
      utils.logger.log("临时文件生成完毕, 准备上传...");
      return utils.rsync({
        local: dirpath + utils.path.SEPARATOR,
        host: 'source.corp.qunar.com',
        path: '/home/q/www/source.qunar.com/' + prjname + '/'
      }, function(err) {
        if (err) {
          return utils.logger.error(err);
        } else {
          return utils.logger.log("DONE.");
        }
      });
    });
  };

  create_temp_images_dir = function(options, cb) {
    var images_path, prjname;
    prjname = utils.path.basename(options.cwd);
    images_path = utils.path.join(options.cwd, 'images' + utils.path.SEPARATOR);
    return temp.mkdir(prjname, function(err, dirpath) {
      utils.logger.log("处理图片目录 " + images_path);
      utils.logger.log("生成临时文件在 " + dirpath);
      utils.path.each_directory(images_path, function(filefullpath) {
        var newpath;
        newpath = utils.path.join(dirpath, convertMD5path(filefullpath).replace(images_path, ''));
        utils.logger.log("正在复制 " + filefullpath + " 至 " + newpath);
        utils.file.mkdirp(utils.path.dirname(newpath));
        return utils.shell.cp(filefullpath, newpath);
      }, true);
      return cb && cb(dirpath);
    });
  };

  err = function(msg) {
    utils.logger.error(msg);
    return utils.exit(1);
  };

  exports.convertMD5path = convertMD5path = function(path) {
    var dir, ext, md5, part;
    dir = utils.path.dirname(path);
    ext = utils.path.extname(path);
    part = utils.path.basename(path, ext);
    md5 = utils.file.md5(path);
    md5 = md5.slice(8, 24);
    return utils.path.join(dir, part + '_' + md5 + ext);
  };

}).call(this);
