// Generated by CoffeeScript 1.4.0
(function() {
  var ModulePath, syspath, utils;

  syspath = require('path');

  utils = require('../../util');

  /* ---------------------------
      模块路径
  */


  ModulePath = (function() {

    function ModulePath(uri) {
      this.uri = uri;
    }

    ModulePath.prototype.parseify = function(path_without_extname) {
      var extname, p, result;
      extname = this.extname();
      if (~ModulePath.EXTLIST.indexOf(extname)) {
        result = utils.file.findify(path_without_extname, ModulePath.EXTLIST);
        if (result === null && utils.path.is_directory(path_without_extname)) {
          p = utils.path.join(path_without_extname, "index");
          result = utils.file.findify(p, ModulePath.EXTLIST);
        }
      }
      if (result) {
        console.info("result>>", result);
        return result;
      } else {
        throw "找不到文件或对应的编译方案 [" + path_without_extname + "] 后缀检查列表为[" + ModulePath.EXTLIST + "]";
      }
    };

    ModulePath.prototype.extname = function() {
      return syspath.extname(this.uri);
    };

    ModulePath.prototype.dirname = function() {
      return syspath.dirname(this.uri);
    };

    ModulePath.prototype.getFullPath = function() {
      return this.uri;
    };

    ModulePath.prototype.getContentType = function() {
      return ModulePath.getContentType(this.extname());
    };

    return ModulePath;

  })();

  /*
      解析子模块真实路径
  
      子模块路径表现形式可以是
          省略后缀名方式, 该方式会认为子模块后缀名默认与parentModule相同
              a/b/c
              a.b.c
              
              后缀名默认匹配顺序为, 如果都找不到就会报错
              [javascript]
              .js / .coffee / .mustache 
              [css]
              .css / .less
  
      子模块的
  
      子模块路径分2种
      1, 相对路径, 相对于父模块的dirname. 如 a/b/c
      2, 库引用路径, 库是由配置指定的路径. 如 core/a/b/c , core是在配置文件中进行配置的
  */


  ModulePath.resolvePath = function(path, parentModule) {
    var path_without_extname, truelypath;
    path_without_extname = ModulePath.parsePath(path, parentModule);
    truelypath = parentModule.path.parseify(path_without_extname);
    utils.logger.trace("[COMPILE] 解析子模块真实路径 " + path + " >>>> " + truelypath);
    return truelypath;
  };

  ModulePath.parsePath = function(path, parentModule) {
    var i, package_path, part, parts, result, _i, _len;
    parts = utils.path.split_path(path, ModulePath.EXTLIST);
    result = [];
    for (i = _i = 0, _len = parts.length; _i < _len; i = ++_i) {
      part = parts[i];
      if (i === 0) {
        package_path = parentModule.config.getPackage(part);
        if (package_path) {
          result.push(package_path);
        } else if (parentModule.config.isUseLibrary(part)) {
          result.push(parentModule.config.parseLibrary(part));
        } else {
          result.push(parentModule.path.dirname());
          result.push(part);
        }
      } else {
        result.push(part);
      }
    }
    if (parts.length === 1 && !package_path && !parentModule.config.isUseLibrary(part)) {
      throw "[COMPILE] 引用模块出错! 找不到在 " + parentModule.path.uri + " 中引用的 " + (parts.join('')) + ", 请检查一下引用路径.";
    }
    return syspath.join.apply(syspath, result);
  };

  ModulePath.getContentType = function(extname) {
    var _ref;
    return (_ref = ModulePath.EXTTABLE[extname]) != null ? _ref.contentType : void 0;
  };

  ModulePath.addExtensionPlugin = function(extName, plugin) {
    ModulePath.EXTLIST.push(extName);
    return ModulePath.EXTTABLE[extName] = plugin;
  };

  ModulePath.getPlugin = function(extName) {
    return ModulePath.EXTTABLE[extName];
  };

  ModulePath.EXTLIST = [];

  ModulePath.EXTTABLE = {};

  exports.ModulePath = ModulePath;

}).call(this);
